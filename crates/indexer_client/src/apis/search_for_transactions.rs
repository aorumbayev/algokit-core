/*
 * Indexer
 *
 * Algorand ledger analytics API.
 *
 * The version of the OpenAPI document: 2.0
 * Generated by: Rust OpenAPI Generator
 */

use algokit_http_client::{HttpClient, HttpMethod};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

use super::parameter_enums::*;
use super::{ContentType, Error, IndexerApiError};

// Import all custom types used by this endpoint
use crate::models::{SearchForTransactions, UnknownJsonValue};

// Import request body type if needed

/// struct for typed errors of method [`search_for_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
#[cfg_attr(feature = "ffi_uniffi", derive(uniffi::Error))]
pub enum SearchForTransactionsError {
    Status400(UnknownJsonValue),
    Status500(UnknownJsonValue),
    DefaultResponse(),
    UnknownValue(crate::models::UnknownJsonValue),
}

/// Search for transactions. Transactions are returned oldest to newest unless the address parameter is used, in which case results are returned newest to oldest.
pub async fn search_for_transactions(
    http_client: &dyn HttpClient,
    limit: Option<u64>,
    next: Option<&str>,
    note_prefix: Option<&str>,
    tx_type: Option<TxType>,
    sig_type: Option<SigType>,
    group_id: Option<&str>,
    txid: Option<&str>,
    round: Option<u64>,
    min_round: Option<u64>,
    max_round: Option<u64>,
    asset_id: Option<u64>,
    before_time: Option<&str>,
    after_time: Option<&str>,
    currency_greater_than: Option<u64>,
    currency_less_than: Option<u64>,
    address: Option<&str>,
    address_role: Option<AddressRole>,
    exclude_close_to: Option<bool>,
    rekey_to: Option<bool>,
    application_id: Option<u64>,
) -> Result<SearchForTransactions, Error> {
    let p_limit = limit;
    let p_next = next;
    let p_note_prefix = note_prefix;
    let p_tx_type = tx_type;
    let p_sig_type = sig_type;
    let p_group_id = group_id;
    let p_txid = txid;
    let p_round = round;
    let p_min_round = min_round;
    let p_max_round = max_round;
    let p_asset_id = asset_id;
    let p_before_time = before_time;
    let p_after_time = after_time;
    let p_currency_greater_than = currency_greater_than;
    let p_currency_less_than = currency_less_than;
    let p_address = address;
    let p_address_role = address_role;
    let p_exclude_close_to = exclude_close_to;
    let p_rekey_to = rekey_to;
    let p_application_id = application_id;

    let path = "/v2/transactions".to_string();

    let mut query_params: HashMap<String, String> = HashMap::new();
    if let Some(value) = p_limit {
        query_params.insert("limit".to_string(), value.to_string());
    }
    if let Some(value) = p_next {
        query_params.insert("next".to_string(), value.to_string());
    }
    if let Some(value) = p_note_prefix {
        query_params.insert("note-prefix".to_string(), value.to_string());
    }
    if let Some(value) = p_tx_type {
        query_params.insert("tx-type".to_string(), value.to_string());
    }
    if let Some(value) = p_sig_type {
        query_params.insert("sig-type".to_string(), value.to_string());
    }
    if let Some(value) = p_group_id {
        query_params.insert("group-id".to_string(), value.to_string());
    }
    if let Some(value) = p_txid {
        query_params.insert("txid".to_string(), value.to_string());
    }
    if let Some(value) = p_round {
        query_params.insert("round".to_string(), value.to_string());
    }
    if let Some(value) = p_min_round {
        query_params.insert("min-round".to_string(), value.to_string());
    }
    if let Some(value) = p_max_round {
        query_params.insert("max-round".to_string(), value.to_string());
    }
    if let Some(value) = p_asset_id {
        query_params.insert("asset-id".to_string(), value.to_string());
    }
    if let Some(value) = p_before_time {
        query_params.insert("before-time".to_string(), value.to_string());
    }
    if let Some(value) = p_after_time {
        query_params.insert("after-time".to_string(), value.to_string());
    }
    if let Some(value) = p_currency_greater_than {
        query_params.insert("currency-greater-than".to_string(), value.to_string());
    }
    if let Some(value) = p_currency_less_than {
        query_params.insert("currency-less-than".to_string(), value.to_string());
    }
    if let Some(value) = p_address {
        query_params.insert("address".to_string(), value.to_string());
    }
    if let Some(value) = p_address_role {
        query_params.insert("address-role".to_string(), value.to_string());
    }
    if let Some(value) = p_exclude_close_to {
        query_params.insert("exclude-close-to".to_string(), value.to_string());
    }
    if let Some(value) = p_rekey_to {
        query_params.insert("rekey-to".to_string(), value.to_string());
    }
    if let Some(value) = p_application_id {
        query_params.insert("application-id".to_string(), value.to_string());
    }

    let mut headers: HashMap<String, String> = HashMap::new();
    headers.insert("Accept".to_string(), "application/json".to_string());

    let body = None;

    let response = http_client
        .request(
            HttpMethod::Get,
            path,
            Some(query_params),
            body,
            Some(headers),
        )
        .await
        .map_err(|e| Error::Http { source: e })?;

    let content_type = response
        .headers
        .get("content-type")
        .map(|s| s.as_str())
        .unwrap_or("application/json");

    match ContentType::from(content_type) {
        ContentType::Json => serde_json::from_slice(&response.body).map_err(|e| Error::Serde {
            message: e.to_string(),
        }),
        ContentType::MsgPack => Err(Error::Serde {
            message: "MsgPack not supported".to_string(),
        }),
        ContentType::Text => {
            let text = String::from_utf8(response.body).map_err(|e| Error::Serde {
                message: e.to_string(),
            })?;
            Err(Error::Serde {
                message: format!("Unexpected text response: {}", text),
            })
        }
        ContentType::Unsupported(ct) => Err(Error::Serde {
            message: format!("Unsupported content type: {}", ct),
        }),
    }
}
