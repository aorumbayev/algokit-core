/*
 * Parameter Enums for Indexer
 *
 * Auto-generated enums for parameters with constrained string values.
 *
 * Generated by: Rust OpenAPI Generator
 */

use serde::{Deserialize, Serialize};
use std::fmt;
use std::str::FromStr;

/// Parameter enum for txtype
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum TxType {
    /// pay
    Pay,
    /// keyreg
    Keyreg,
    /// acfg
    Acfg,
    /// axfer
    Axfer,
    /// afrz
    Afrz,
    /// appl
    Appl,
    /// stpf
    Stpf,
    /// hb
    Hb,
}

impl fmt::Display for TxType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let value = match self {
            TxType::Pay => "pay",
            TxType::Keyreg => "keyreg",
            TxType::Acfg => "acfg",
            TxType::Axfer => "axfer",
            TxType::Afrz => "afrz",
            TxType::Appl => "appl",
            TxType::Stpf => "stpf",
            TxType::Hb => "hb",
        };
        write!(f, "{}", value)
    }
}

impl FromStr for TxType {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "pay" => Ok(TxType::Pay),
            "keyreg" => Ok(TxType::Keyreg),
            "acfg" => Ok(TxType::Acfg),
            "axfer" => Ok(TxType::Axfer),
            "afrz" => Ok(TxType::Afrz),
            "appl" => Ok(TxType::Appl),
            "stpf" => Ok(TxType::Stpf),
            "hb" => Ok(TxType::Hb),
            _ => Err(format!("Invalid TxType: {}", s)),
        }
    }
}

/// SigType filters just results using the specified type of signature:
///   * sig - Standard
///   * msig - MultiSig
///   * lsig - LogicSig
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum SigType {
    /// sig
    Sig,
    /// msig
    Msig,
    /// lsig
    Lsig,
}

impl fmt::Display for SigType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let value = match self {
            SigType::Sig => "sig",
            SigType::Msig => "msig",
            SigType::Lsig => "lsig",
        };
        write!(f, "{}", value)
    }
}

impl FromStr for SigType {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "sig" => Ok(SigType::Sig),
            "msig" => Ok(SigType::Msig),
            "lsig" => Ok(SigType::Lsig),
            _ => Err(format!("Invalid SigType: {}", s)),
        }
    }
}

/// Combine with the address parameter to define what type of address to search for.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum AddressRole {
    /// sender
    Sender,
    /// receiver
    Receiver,
    /// freeze-target
    FreezeTarget,
}

impl fmt::Display for AddressRole {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let value = match self {
            AddressRole::Sender => "sender",
            AddressRole::Receiver => "receiver",
            AddressRole::FreezeTarget => "freeze-target",
        };
        write!(f, "{}", value)
    }
}

impl FromStr for AddressRole {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "sender" => Ok(AddressRole::Sender),
            "receiver" => Ok(AddressRole::Receiver),
            "freeze-target" => Ok(AddressRole::FreezeTarget),
            _ => Err(format!("Invalid AddressRole: {}", s)),
        }
    }
}
