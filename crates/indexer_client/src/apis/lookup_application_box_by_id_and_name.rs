/*
 * Indexer
 *
 * Algorand ledger analytics API.
 *
 * The version of the OpenAPI document: 2.0
 * Generated by: Rust OpenAPI Generator
 */

use algokit_http_client::{HttpClient, HttpMethod};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

use super::{ContentType, Error, IndexerApiError};

// Import all custom types used by this endpoint
use crate::models::Box;

// Import request body type if needed

/// struct for typed errors of method [`lookup_application_box_by_id_and_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupApplicationBoxByIdAndNameError {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    Status500(serde_json::Value),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// Given an application ID and box name, returns base64 encoded box name and value. Box names must be in the goal app call arg form 'encoding:value'. For ints, use the form 'int:1234'. For raw bytes, encode base 64 and use 'b64' prefix as in 'b64:A=='. For printable strings, use the form 'str:hello'. For addresses, use the form 'addr:XYZ...'.
pub async fn lookup_application_box_by_id_and_name(
    http_client: &dyn HttpClient,
    application_id: u64,
    name: &str,
) -> Result<crate::models::Box, Error> {
    let p_application_id = application_id;
    let p_name = name;

    let path = format!(
        "/v2/applications/{application_id}/box",
        application_id = p_application_id
    );

    let mut query_params: HashMap<String, String> = HashMap::new();
    query_params.insert("name".to_string(), p_name.to_string());

    let mut headers: HashMap<String, String> = HashMap::new();
    headers.insert("Content-Type".to_string(), "application/json".to_string());
    headers.insert("Accept".to_string(), "application/json".to_string());

    let body = None;

    let response = http_client
        .request(
            HttpMethod::Get,
            path,
            Some(query_params),
            body,
            Some(headers),
        )
        .await
        .map_err(|e| Error::Http { source: e })?;

    let content_type = response
        .headers
        .get("content-type")
        .map(|s| s.as_str())
        .unwrap_or("application/json");

    match ContentType::from(content_type) {
        ContentType::Json => serde_json::from_slice(&response.body).map_err(|e| Error::Serde {
            message: e.to_string(),
        }),
        ContentType::MsgPack => Err(Error::Serde {
            message: "MsgPack not supported".to_string(),
        }),
        ContentType::Text => {
            let text = String::from_utf8(response.body).map_err(|e| Error::Serde {
                message: e.to_string(),
            })?;
            Err(Error::Serde {
                message: format!("Unexpected text response: {}", text),
            })
        }
        ContentType::Unsupported(ct) => Err(Error::Serde {
            message: format!("Unsupported content type: {}", ct),
        }),
    }
}
