/*
 * Algod REST API.
 *
 * API endpoint for algod operations.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: contact@algorand.com
 * Generated by: Rust OpenAPI Generator
 */

use algokit_http_client::{HttpClient, HttpMethod};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

use super::parameter_enums::*;
use super::{AlgodApiError, ContentType, Error};
use algokit_transact::AlgorandMsgpack;

// Import all custom types used by this endpoint
use crate::models::{AccountAssetInformation, ErrorResponse};

// Import request body type if needed

/// struct for typed errors of method [`account_asset_information`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountAssetInformationError {
    Status400(ErrorResponse),
    Status401(ErrorResponse),
    Status500(ErrorResponse),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// Given a specific account public key and asset ID, this call returns the account's asset holding and asset parameters (if either exist). Asset parameters will only be returned if the provided address is the asset's creator.
pub async fn account_asset_information(
    http_client: &dyn HttpClient,
    address: &str,
    asset_id: u64,
    format: Option<Format>,
) -> Result<AccountAssetInformation, Error> {
    let p_address = address;
    let p_asset_id = asset_id;
    let p_format = format;

    let path = format!(
        "/v2/accounts/{address}/assets/{asset_id}",
        address = crate::apis::urlencode(p_address),
        asset_id = p_asset_id
    );

    let mut query_params: HashMap<String, String> = HashMap::new();
    if let Some(value) = p_format {
        query_params.insert("format".to_string(), value.to_string());
    }

    let use_msgpack = p_format.map(|f| f != Format::Json).unwrap_or(true);

    let mut headers: HashMap<String, String> = HashMap::new();
    if use_msgpack {
        headers.insert(
            "Content-Type".to_string(),
            "application/msgpack".to_string(),
        );
        headers.insert("Accept".to_string(), "application/msgpack".to_string());
    } else {
        headers.insert("Content-Type".to_string(), "application/json".to_string());
        headers.insert("Accept".to_string(), "application/json".to_string());
    }

    let body = None;

    let response = http_client
        .request(
            HttpMethod::Get,
            path,
            Some(query_params),
            body,
            Some(headers),
        )
        .await
        .map_err(|e| Error::Http { source: e })?;

    let content_type = response
        .headers
        .get("content-type")
        .map(|s| s.as_str())
        .unwrap_or("application/json");

    match ContentType::from(content_type) {
        ContentType::Json => serde_json::from_slice(&response.body).map_err(|e| Error::Serde {
            message: e.to_string(),
        }),
        ContentType::MsgPack => rmp_serde::from_slice(&response.body).map_err(|e| Error::Serde {
            message: e.to_string(),
        }),
        ContentType::Text => {
            let text = String::from_utf8(response.body).map_err(|e| Error::Serde {
                message: e.to_string(),
            })?;
            Err(Error::Serde {
                message: format!("Unexpected text response: {}", text),
            })
        }
        ContentType::Unsupported(ct) => Err(Error::Serde {
            message: format!("Unsupported content type: {}", ct),
        }),
    }
}
