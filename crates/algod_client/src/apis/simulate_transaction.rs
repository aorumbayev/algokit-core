/*
 * Algod REST API.
 *
 * API endpoint for algod operations.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: contact@algorand.com
 * Generated by: Rust OpenAPI Generator
 */

use algokit_http_client::{HttpClient, HttpMethod};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

use super::parameter_enums::*;
use super::{AlgodApiError, ContentType, Error};
use algokit_transact::AlgorandMsgpack;

// Import all custom types used by this endpoint
use crate::models::{ErrorResponse, SimulateTransaction};

// Import request body type if needed
use crate::models::SimulateRequest;

/// struct for typed errors of method [`simulate_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
#[cfg_attr(feature = "ffi_uniffi", derive(uniffi::Error))]
pub enum SimulateTransactionError {
    Status400(ErrorResponse),
    Status401(ErrorResponse),
    Status500(ErrorResponse),
    Status503(ErrorResponse),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(crate::models::UnknownJsonValue),
}

/// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
pub async fn simulate_transaction(
    http_client: &dyn HttpClient,
    request: SimulateRequest,
    format: Option<Format>,
) -> Result<SimulateTransaction, Error> {
    let p_format = format;
    let p_request = request;

    let path = "/v2/transactions/simulate".to_string();

    let mut query_params: HashMap<String, String> = HashMap::new();
    if let Some(value) = p_format {
        query_params.insert("format".to_string(), value.to_string());
    }

    let use_msgpack = p_format.map(|f| f != Format::Json).unwrap_or(true);

    let mut headers: HashMap<String, String> = HashMap::new();
    if use_msgpack {
        headers.insert(
            "Content-Type".to_string(),
            "application/msgpack".to_string(),
        );
        headers.insert("Accept".to_string(), "application/msgpack".to_string());
    } else {
        headers.insert("Content-Type".to_string(), "application/json".to_string());
        headers.insert("Accept".to_string(), "application/json".to_string());
    }

    let body = if use_msgpack {
        Some(
            rmp_serde::to_vec_named(&p_request).map_err(|e| Error::Serde {
                message: e.to_string(),
            })?,
        )
    } else {
        Some(serde_json::to_vec(&p_request).map_err(|e| Error::Serde {
            message: e.to_string(),
        })?)
    };

    let response = http_client
        .request(
            HttpMethod::Post,
            path,
            Some(query_params),
            body,
            Some(headers),
        )
        .await
        .map_err(|e| Error::Http { source: e })?;

    let content_type = response
        .headers
        .get("content-type")
        .map(|s| s.as_str())
        .unwrap_or("application/json");

    match ContentType::from(content_type) {
        ContentType::Json => serde_json::from_slice(&response.body).map_err(|e| Error::Serde {
            message: e.to_string(),
        }),
        ContentType::MsgPack => rmp_serde::from_slice(&response.body).map_err(|e| Error::Serde {
            message: e.to_string(),
        }),
        ContentType::Text => {
            let text = String::from_utf8(response.body).map_err(|e| Error::Serde {
                message: e.to_string(),
            })?;
            Err(Error::Serde {
                message: format!("Unexpected text response: {}", text),
            })
        }
        ContentType::Unsupported(ct) => Err(Error::Serde {
            message: format!("Unsupported content type: {}", ct),
        }),
    }
}
