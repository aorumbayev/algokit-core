/*
 * Algod REST API.
 *
 * API endpoint for algod operations.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: contact@algorand.com
 * Generated by: Rust OpenAPI Generator
 */

use algokit_http_client::{HttpClient, HttpMethod};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

use super::{AlgodApiError, ContentType, Error};

// Import all custom types used by this endpoint
use crate::models::{Asset, ErrorResponse};

// Import request body type if needed

/// struct for typed errors of method [`get_asset_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssetByIdError {
    Status400(ErrorResponse),
    Status401(ErrorResponse),
    Status404(ErrorResponse),
    Status500(ErrorResponse),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// Given a asset ID, it returns asset information including creator, name, total supply and special addresses.
pub async fn get_asset_by_id(http_client: &dyn HttpClient, asset_id: u64) -> Result<Asset, Error> {
    let p_asset_id = asset_id;

    let path = format!("/v2/assets/{asset_id}", asset_id = p_asset_id);

    let query_params: HashMap<String, String> = HashMap::new();

    let mut headers: HashMap<String, String> = HashMap::new();
    headers.insert("Content-Type".to_string(), "application/json".to_string());
    headers.insert("Accept".to_string(), "application/json".to_string());

    let body = None;

    let response = http_client
        .request(
            HttpMethod::Get,
            path,
            Some(query_params),
            body,
            Some(headers),
        )
        .await
        .map_err(Error::Http)?;

    let content_type = response
        .headers
        .get("content-type")
        .map(|s| s.as_str())
        .unwrap_or("application/json");

    match ContentType::from(content_type) {
        ContentType::Json => {
            serde_json::from_slice(&response.body).map_err(|e| Error::Serde(e.to_string()))
        }
        ContentType::MsgPack => {
            rmp_serde::from_slice(&response.body).map_err(|e| Error::Serde(e.to_string()))
        }
        ContentType::Text => {
            let text = String::from_utf8(response.body).map_err(|e| Error::Serde(e.to_string()))?;
            Err(Error::Serde(format!("Unexpected text response: {}", text)))
        }
        ContentType::Unsupported(ct) => {
            Err(Error::Serde(format!("Unsupported content type: {}", ct)))
        }
    }
}
