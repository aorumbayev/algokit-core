# coding: utf-8

"""
    Algod REST API.

    API endpoint for algod operations.

    The version of the OpenAPI document: 0.0.1
    Contact: contact@algorand.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json
# Optional support for Algorand compact MessagePack via the `algokit_transact`
# Python bindings (built from the Rust crate). We do the import lazily so that
# the generated client can still function even if the optional binary wheel is
# not available on the target platform.
try:
    from algokit_transact import (
        encode_json_to_msgpack as _ak_encode_msgpack,
        decode_msgpack_to_json as _ak_decode_msgpack,
        ModelType as _AkModelType,
    )
except ModuleNotFoundError:  # pragma: no cover – optional dependency
    _ak_encode_msgpack = None  # type: ignore
    _ak_decode_msgpack = None  # type: ignore
    _AkModelType = None  # type: ignore

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class GetStatus200Response(BaseModel):
    """
    NodeStatus contains the information about a node status
    """ # noqa: E501
    catchup_time: StrictInt = Field(description="CatchupTime in nanoseconds", alias="catchup-time")
    last_round: StrictInt = Field(description="LastRound indicates the last round seen", alias="last-round")
    last_version: StrictStr = Field(description="LastVersion indicates the last consensus version supported", alias="last-version")
    next_version: StrictStr = Field(description="NextVersion of consensus protocol to use", alias="next-version")
    next_version_round: StrictInt = Field(description="NextVersionRound is the round at which the next consensus version will apply", alias="next-version-round")
    next_version_supported: StrictBool = Field(description="NextVersionSupported indicates whether the next consensus version is supported by this node", alias="next-version-supported")
    stopped_at_unsupported_round: StrictBool = Field(description="StoppedAtUnsupportedRound indicates that the node does not support the new rounds and has stopped making progress", alias="stopped-at-unsupported-round")
    time_since_last_round: StrictInt = Field(description="TimeSinceLastRound in nanoseconds", alias="time-since-last-round")
    last_catchpoint: Optional[StrictStr] = Field(default=None, description="The last catchpoint seen by the node", alias="last-catchpoint")
    catchpoint: Optional[StrictStr] = Field(default=None, description="The current catchpoint that is being caught up to")
    catchpoint_total_accounts: Optional[StrictInt] = Field(default=None, description="The total number of accounts included in the current catchpoint", alias="catchpoint-total-accounts")
    catchpoint_processed_accounts: Optional[StrictInt] = Field(default=None, description="The number of accounts from the current catchpoint that have been processed so far as part of the catchup", alias="catchpoint-processed-accounts")
    catchpoint_verified_accounts: Optional[StrictInt] = Field(default=None, description="The number of accounts from the current catchpoint that have been verified so far as part of the catchup", alias="catchpoint-verified-accounts")
    catchpoint_total_kvs: Optional[StrictInt] = Field(default=None, description="The total number of key-values (KVs) included in the current catchpoint", alias="catchpoint-total-kvs")
    catchpoint_processed_kvs: Optional[StrictInt] = Field(default=None, description="The number of key-values (KVs) from the current catchpoint that have been processed so far as part of the catchup", alias="catchpoint-processed-kvs")
    catchpoint_verified_kvs: Optional[StrictInt] = Field(default=None, description="The number of key-values (KVs) from the current catchpoint that have been verified so far as part of the catchup", alias="catchpoint-verified-kvs")
    catchpoint_total_blocks: Optional[StrictInt] = Field(default=None, description="The total number of blocks that are required to complete the current catchpoint catchup", alias="catchpoint-total-blocks")
    catchpoint_acquired_blocks: Optional[StrictInt] = Field(default=None, description="The number of blocks that have already been obtained by the node as part of the catchup", alias="catchpoint-acquired-blocks")
    upgrade_delay: Optional[StrictInt] = Field(default=None, description="Upgrade delay", alias="upgrade-delay")
    upgrade_node_vote: Optional[StrictBool] = Field(default=None, description="This node's upgrade vote", alias="upgrade-node-vote")
    upgrade_votes_required: Optional[StrictInt] = Field(default=None, description="Yes votes required for consensus upgrade", alias="upgrade-votes-required")
    upgrade_votes: Optional[StrictInt] = Field(default=None, description="Total votes cast for consensus upgrade", alias="upgrade-votes")
    upgrade_yes_votes: Optional[StrictInt] = Field(default=None, description="Yes votes cast for consensus upgrade", alias="upgrade-yes-votes")
    upgrade_no_votes: Optional[StrictInt] = Field(default=None, description="No votes cast for consensus upgrade", alias="upgrade-no-votes")
    upgrade_next_protocol_vote_before: Optional[StrictInt] = Field(default=None, description="Next protocol round", alias="upgrade-next-protocol-vote-before")
    upgrade_vote_rounds: Optional[StrictInt] = Field(default=None, description="Total voting rounds for current upgrade", alias="upgrade-vote-rounds")
    __properties: ClassVar[List[str]] = ["catchup-time", "last-round", "last-version", "next-version", "next-version-round", "next-version-supported", "stopped-at-unsupported-round", "time-since-last-round", "last-catchpoint", "catchpoint", "catchpoint-total-accounts", "catchpoint-processed-accounts", "catchpoint-verified-accounts", "catchpoint-total-kvs", "catchpoint-processed-kvs", "catchpoint-verified-kvs", "catchpoint-total-blocks", "catchpoint-acquired-blocks", "upgrade-delay", "upgrade-node-vote", "upgrade-votes-required", "upgrade-votes", "upgrade-yes-votes", "upgrade-no-votes", "upgrade-next-protocol-vote-before", "upgrade-vote-rounds"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GetStatus200Response from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GetStatus200Response from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "catchup-time": obj.get("catchup-time"),
            "last-round": obj.get("last-round"),
            "last-version": obj.get("last-version"),
            "next-version": obj.get("next-version"),
            "next-version-round": obj.get("next-version-round"),
            "next-version-supported": obj.get("next-version-supported"),
            "stopped-at-unsupported-round": obj.get("stopped-at-unsupported-round"),
            "time-since-last-round": obj.get("time-since-last-round"),
            "last-catchpoint": obj.get("last-catchpoint"),
            "catchpoint": obj.get("catchpoint"),
            "catchpoint-total-accounts": obj.get("catchpoint-total-accounts"),
            "catchpoint-processed-accounts": obj.get("catchpoint-processed-accounts"),
            "catchpoint-verified-accounts": obj.get("catchpoint-verified-accounts"),
            "catchpoint-total-kvs": obj.get("catchpoint-total-kvs"),
            "catchpoint-processed-kvs": obj.get("catchpoint-processed-kvs"),
            "catchpoint-verified-kvs": obj.get("catchpoint-verified-kvs"),
            "catchpoint-total-blocks": obj.get("catchpoint-total-blocks"),
            "catchpoint-acquired-blocks": obj.get("catchpoint-acquired-blocks"),
            "upgrade-delay": obj.get("upgrade-delay"),
            "upgrade-node-vote": obj.get("upgrade-node-vote"),
            "upgrade-votes-required": obj.get("upgrade-votes-required"),
            "upgrade-votes": obj.get("upgrade-votes"),
            "upgrade-yes-votes": obj.get("upgrade-yes-votes"),
            "upgrade-no-votes": obj.get("upgrade-no-votes"),
            "upgrade-next-protocol-vote-before": obj.get("upgrade-next-protocol-vote-before"),
            "upgrade-vote-rounds": obj.get("upgrade-vote-rounds")
        })
        return _obj

    def to_msgpack(self) -> bytes:  # pragma: no cover – thin wrapper
        """Return the compact Algorand MessagePack representation of this model.

        Requires the optional ``algokit_transact`` binary package to be
        installed. If the model is not one of the types supported by that
        package (for example *SimulateRequest* or *SimulateTransaction200Response*)
        a :class:`NotImplementedError` is raised.
        """
        if _ak_encode_msgpack is None or _AkModelType is None:
            raise RuntimeError(
                "algokit_transact is not available — install the algokit_transact package"
                "to use MessagePack helpers"
            )

        try:
            model_type = _AkModelType[self.__class__.__name__]
        except KeyError as exc:  # pragma: no cover
            # Fallback: convert CamelCase -> UPPER_SNAKE_CASE (SimulateRequest -> SIMULATE_REQUEST)
            variant_name = re.sub(r'(?<!^)(?=[A-Z])', '_', self.__class__.__name__).upper()
            try:
                model_type = _AkModelType[variant_name]
            except KeyError as exc:  # pragma: no cover
                raise NotImplementedError(
                    f"Model {self.__class__.__name__} ({variant_name}) is not supported by algokit_transact"
                ) from exc

        return _ak_encode_msgpack(model_type, self.to_json())  # type: ignore[arg-type]

    @classmethod
    def from_msgpack(cls, data: bytes) -> "Self":  # pragma: no cover – thin wrapper
        """Create a new instance from Algorand MessagePack *data*.

        The inverse of :pymeth:`to_msgpack`. Requires
        ``algokit_transact`` to be importable.
        """
        if _ak_decode_msgpack is None or _AkModelType is None:
            raise RuntimeError(
                "algokit_transact is not available — install the algokit_transact package"
                "to use MessagePack helpers"
            )

        try:
            model_type = _AkModelType[cls.__name__]
        except KeyError as exc:  # pragma: no cover
            variant_name = re.sub(r'(?<!^)(?=[A-Z])', '_', cls.__name__).upper()
            try:
                model_type = _AkModelType[variant_name]
            except KeyError as exc:  # pragma: no cover
                raise NotImplementedError(
                    f"Model {cls.__name__} ({variant_name}) is not supported by algokit_transact"
                ) from exc

        json_str = _ak_decode_msgpack(model_type, data)  # type: ignore[arg-type]
        return cls.from_json(json_str)


