/*
 * {{ spec.info.title }}
 *
 * {{ spec.info.description or "API client generated from OpenAPI specification" }}
 *
 * The version of the OpenAPI document: {{ spec.info.version }}
 {% if spec.info.contact and spec.info.contact.email %} * Contact: {{ spec.info.contact.email }}
 {% endif %} * Generated by: Rust OpenAPI Generator
 */

use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

// Import all response types
{% set used_types = get_all_used_types(operations) %}
{% if used_types %}
use crate::models::{
{% for used_type in used_types %}
    {{ used_type }},
{% endfor %}
};
{% endif %}

{% for operation in operations %}
/// struct for typed errors of method [`{{ operation.rust_function_name }}`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
#[cfg_attr(feature = "ffi_uniffi", derive(uniffi::Error))]
pub enum {{ operation.rust_error_enum }} {
{% for error_type in get_error_types(operation) %}
    {{ error_type }},
{% endfor %}
}

{% endfor %}

{% for operation in operations %}
{% if operation.description %}
{{ operation.description | rust_doc_comment }}
{% elif operation.summary %}
{{ operation.summary | rust_doc_comment }}
{% endif %}
pub async fn {{ operation.rust_function_name }}(
    configuration: &configuration::Configuration,
{% for param in operation.parameters %}
    {% if param.required %}{{ param.rust_name }}: {% if param.rust_type == "String" %}&str{% else %}{{ param.rust_type }}{% endif %},
    {% else %}{{ param.rust_name }}: Option<{% if param.rust_type == "String" %}&str{% else %}{{ param.rust_type }}{% endif %}>,
    {% endif %}
{% endfor %}
) -> Result<{% if get_success_response_type(operation) %}{{ get_success_response_type(operation) }}{% else %}(){% endif %}, Error<{{ operation.rust_error_enum }}>> {
    // add a prefix to parameters to efficiently prevent name collisions
{% for param in operation.parameters %}
    let p_{{ param.rust_name }} = {{ param.rust_name }};
{% endfor %}

    let uri_str = format!("{}{{ operation.path | replace("-", "_") }}", configuration.base_path{% if has_path_parameters(operation) %}, {% for param in get_path_parameters(operation) %}{{ param.name | replace("-", "_") }}={% if param.rust_type in ["i32", "i64", "u32", "u64", "f32", "f64"] %}p_{{ param.rust_name }}{% else %}crate::apis::urlencode(p_{{ param.rust_name }}){% endif %}{% if not loop.last %}, {% endif %}{% endfor %}{% endif %});
    let mut req_builder = configuration.client.request(reqwest::Method::{{ operation.method }}, &uri_str);

{% if has_query_parameters(operation) %}
{% for param in get_query_parameters(operation) %}
    {% if param.required %}
    req_builder = req_builder.query(&[("{{ param.name }}", &p_{{ param.rust_name }}.to_string())]);
    {% else %}
    if let Some(ref param_value) = p_{{ param.rust_name }} {
        req_builder = req_builder.query(&[("{{ param.name }}", &param_value.to_string())]);
    }
    {% endif %}
{% endfor %}
{% endif %}

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    {% if get_success_response_type(operation) %}
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);
    {% endif %}

    if !status.is_client_error() && !status.is_server_error() {
        {% if get_success_response_type(operation) %}
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `{{ get_success_response_type(operation) }}`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `{{ get_success_response_type(operation) }}`")))),
        }
        {% else %}
        let _content = resp.text().await?;
        Ok(())
        {% endif %}
    } else {
        let content = resp.text().await?;
        let entity: Option<{{ operation.rust_error_enum }}> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

{% endfor %}

