/*
 * {{ spec.info.title }}
 *
 * {{ spec.info.description or "API client generated from OpenAPI specification" }}
 *
 * The version of the OpenAPI document: {{ spec.info.version }}
 {% if spec.info.contact and spec.info.contact.email %} * Contact: {{ spec.info.contact.email }}
 {% endif %} * Generated by: Rust OpenAPI Generator
 */

use serde::{Deserialize, Serialize};
use algokit_http_client::{HttpClient, HttpMethod};
use std::collections::HashMap;

use super::{Error, AlgodApiError, ContentType};
{% if operation.supports_msgpack %}
use algokit_transact::AlgorandMsgpack;
{% endif %}
{% set param_enums = collect_parameter_enums([operation]) %}
{% if param_enums %}
use super::parameter_enums::*;
{% endif %}

// Import all custom types used by this endpoint
{% set used_types = get_operation_used_types(operation) %}
{% if used_types %}
use crate::models::{
{% for used_type in used_types %}
    {{ used_type }},
{% endfor %}
};
{% endif %}

// Import request body type if needed
{% if has_request_body(operation) %}
{% set request_body_type = get_request_body_type(operation) %}
{% if should_import_request_body_type(request_body_type) %}
use crate::models::{{ request_body_type }};
{% endif %}
{% endif %}

/// struct for typed errors of method [`{{ operation.rust_function_name }}`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum {{ operation.rust_error_enum }} {
{% set error_types = get_error_types(operation) %}
{% for error_type in error_types %}
    {{ error_type }},
{% endfor %}
}

{% if operation.description %}
{{ operation.description | rust_doc_comment }}
{% elif operation.summary %}
{{ operation.summary | rust_doc_comment }}
{% endif %}
pub async fn {{ operation.rust_function_name }}(
    http_client: &dyn HttpClient,
{% if has_request_body(operation) %}
    {% set request_body_name = get_request_body_name(operation) %}
    {% set request_body_type = get_request_body_type(operation) %}
    {% if is_request_body_required(operation) %}{{ request_body_name }}: {{ request_body_type }},
    {% else %}{{ request_body_name }}: Option<{{ request_body_type }}>,
    {% endif %}
{% endif %}
{% for param in operation.parameters %}
    {% if param.is_enum_parameter %}
        {% if param.required %}{{ param.rust_name }}: {{ param.rust_enum_type }},
        {% else %}{{ param.rust_name }}: Option<{{ param.rust_enum_type }}>,
        {% endif %}
    {% else %}
        {% if param.required %}{{ param.rust_name }}: {% if param.rust_type == "String" %}&str{% else %}{{ param.rust_type }}{% endif %},
        {% else %}{{ param.rust_name }}: Option<{% if param.rust_type == "String" %}&str{% else %}{{ param.rust_type }}{% endif %}>,
        {% endif %}
    {% endif %}
{% endfor %}

) -> Result<{% if get_success_response_type(operation) %}{{ get_success_response_type(operation) }}{% else %}(){% endif %}, Error> {
    {% for param in operation.parameters %}
    let p_{{ param.rust_name }} = {{ param.rust_name }};
    {% endfor %}
    {% if has_request_body(operation) %}
    let p_{{ get_request_body_name(operation) }} = {{ get_request_body_name(operation) }};
    {% endif %}

    {% set rust_path = operation.path.replace('-', '_') %}
    {% set path_params = get_path_parameters(operation) %}
    {% if path_params %}
    let path = format!("{{ rust_path }}", {% for p in path_params %}{{p.rust_name}}={% if p.rust_type == "String" %}crate::apis::urlencode(p_{{p.rust_name}}){% else %}p_{{p.rust_name}}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %});
    {% else %}
    let path = "{{ rust_path }}".to_string();
    {% endif %}

    let{% if get_query_parameters(operation) %} mut{% endif %} query_params: HashMap<String, String> = HashMap::new();
    {% for param in get_query_parameters(operation) %}
    {% if param.required %}
        query_params.insert("{{ param.name }}".to_string(), p_{{ param.rust_name }}.to_string());
    {% else %}
    if let Some(value) = p_{{ param.rust_name }} {
        query_params.insert("{{ param.name }}".to_string(), value.to_string());
    }
    {% endif %}
    {% endfor %}

    {% if not operation.supports_msgpack %}
    let mut headers: HashMap<String, String> = HashMap::new();
    headers.insert("Content-Type".to_string(), "application/json".to_string());
    headers.insert("Accept".to_string(), "application/json".to_string());

    let body = {% if has_request_body(operation) %}
        Some(serde_json::to_vec(&p_{{ get_request_body_name(operation) }}).map_err(|e| Error::Serde(e.to_string()))?)
    {% else %}
    None
    {% endif %};
    {% elif not has_format_parameter(operation) %}
    let mut headers: HashMap<String, String> = HashMap::new();
    headers.insert("Content-Type".to_string(), "application/msgpack".to_string());
    headers.insert("Accept".to_string(), "application/msgpack".to_string());

    let body = {% if has_request_body(operation) %}
        {% if operation.request_body_supports_msgpack %}
        {% if request_body_type == "Vec<u8>" %}
        Some(p_{{ get_request_body_name(operation) }})
        {% else %}
        Some(rmp_serde::to_vec_named(&p_{{ get_request_body_name(operation) }}).map_err(|e| Error::Serde(e.to_string()))?)
        {% endif %}
        {% else %}
        Some(serde_json::to_vec(&p_{{ get_request_body_name(operation) }}).map_err(|e| Error::Serde(e.to_string()))?)
        {% endif %}
    {% else %}
    None
    {% endif %};
    {% else %}
    let use_msgpack = {% for param in operation.parameters if param.name == "format" %}{% if param.is_enum_parameter %}p_{{ param.rust_name }}.map(|f| f != Format::Json).unwrap_or(true){% else %}p_{{ param.rust_name }}.map(|f| f != "json").unwrap_or(true){% endif %}{% endfor %};

    let mut headers: HashMap<String, String> = HashMap::new();
    if use_msgpack {
        headers.insert("Content-Type".to_string(), "application/msgpack".to_string());
        headers.insert("Accept".to_string(), "application/msgpack".to_string());
    } else {
        headers.insert("Content-Type".to_string(), "application/json".to_string());
        headers.insert("Accept".to_string(), "application/json".to_string());
    }

    let body = {% if has_request_body(operation) %}
        {% if operation.request_body_supports_msgpack %}
        if use_msgpack {
            {% if request_body_type == "Vec<u8>" %}
            Some(p_{{ get_request_body_name(operation) }})
            {% else %}
            Some(rmp_serde::to_vec_named(&p_{{ get_request_body_name(operation) }}).map_err(|e| Error::Serde(e.to_string()))?)
            {% endif %}
        } else {
            Some(serde_json::to_vec(&p_{{ get_request_body_name(operation) }}).map_err(|e| Error::Serde(e.to_string()))?)
        }
        {% else %}
        Some(serde_json::to_vec(&p_{{ get_request_body_name(operation) }}).map_err(|e| Error::Serde(e.to_string()))?)
        {% endif %}
    {% else %}
    None
    {% endif %};
    {% endif %}

    let response = http_client
        .request(
            {{ operation.method | http_method_enum }},
            path,
            Some(query_params),
            body,
            Some(headers),
        )
        .await
        .map_err(Error::Http)?;

    {% if get_success_response_type(operation) %}
    let content_type = response
        .headers
        .get("content-type")
        .map(|s| s.as_str())
        .unwrap_or("application/json");

    match ContentType::from(content_type) {
        ContentType::Json => serde_json::from_slice(&response.body).map_err(|e| Error::Serde(e.to_string())),
        ContentType::MsgPack => rmp_serde::from_slice(&response.body).map_err(|e| Error::Serde(e.to_string())),
        ContentType::Text => {
            let text = String::from_utf8(response.body).map_err(|e| Error::Serde(e.to_string()))?;
            Err(Error::Serde(format!("Unexpected text response: {}", text)))
        },
        ContentType::Unsupported(ct) => Err(Error::Serde(format!("Unsupported content type: {}", ct))),
    }
    {% else %}
    let _ = response;
    Ok(())
    {% endif %}
}
