{% set client_type = get_client_type(spec) %}
/*
 * {{ spec.info.title }}
 *
 * {{ spec.info.description or "API client generated from OpenAPI specification" }}
 *
 * The version of the OpenAPI document: {{ spec.info.version }}
 {% if spec.info.contact and spec.info.contact.email %} * Contact: {{ spec.info.contact.email }}
 {% endif %} * Generated by: Rust OpenAPI Generator
 */

// Consolidated client
pub mod client;

{% set param_enums = collect_parameter_enums(operations) %}
{% if param_enums %}
// Parameter enums for type-safe API parameters
pub mod parameter_enums;
{% endif %}

// Individual endpoint modules
{% for operation in operations %}
pub mod {{ operation.rust_function_name }};
{% endfor %}

use snafu::Snafu;

/// Unified error type that can represent any API error from any endpoint
#[derive(Debug, Snafu)]
pub enum {{ client_type }}ApiError {
{% for operation in operations %}
    #[snafu(display("{{ operation.rust_function_name | title }} error: {error:?}"))]
    {{ operation.rust_function_name | pascal_case }} { error: {{ operation.rust_function_name }}::{{ operation.rust_error_enum }} },
{% endfor %}
    #[snafu(display("Unknown API error: {message}"))]
    Unknown { message: String },
}

{% for operation in operations %}
impl From<{{ operation.rust_function_name }}::{{ operation.rust_error_enum }}> for {{ client_type }}ApiError {
    fn from(err: {{ operation.rust_function_name }}::{{ operation.rust_error_enum }}) -> Self {
        {{ client_type }}ApiError::{{ operation.rust_function_name | pascal_case }} { error: err }
    }
}

{% endfor %}

/// The main error type for all {{ client_type | lower }} client operations
#[derive(Debug, Snafu)]
pub enum Error {
    #[snafu(display("HTTP error: {source}"))]
    Http { source: algokit_http_client::HttpError },
    #[snafu(display("Serialization error: {message}"))]
    Serde { message: String },
    #[snafu(display("API error: {source}"))]
    Api { source: {{ client_type }}ApiError },
}

#[derive(Debug, PartialEq, Eq)]
pub enum ContentType {
    Json,
    MsgPack,
    Text,
    Unsupported(String),
}

impl From<&str> for ContentType {
    fn from(content_type: &str) -> Self {
        if content_type.contains("application/json") {
            ContentType::Json
        } else if content_type.contains("application/msgpack") {
            ContentType::MsgPack
        } else if content_type.contains("text/plain") {
            ContentType::Text
        } else {
            ContentType::Unsupported(content_type.to_string())
        }
    }
}

pub fn urlencode<T: AsRef<str>>(s: T) -> String {
    ::url::form_urlencoded::byte_serialize(s.as_ref().as_bytes()).collect()
}

// Re-export the consolidated client
pub use client::{{ client_type }}Client;

{% if param_enums %}
// Re-export parameter enums
pub use parameter_enums::*;
{% endif %}

// Re-export all endpoint functions
{% for operation in operations %}
pub use {{ operation.rust_function_name }}::{
    {{ operation.rust_function_name }},
    {{ operation.rust_error_enum }},
};
{% endfor %}
