/*
 * {{ spec.info.title }}
 *
 * {{ spec.info.description or "API client generated from OpenAPI specification" }}
 *
 * The version of the OpenAPI document: {{ spec.info.version }}
 {% if spec.info.contact and spec.info.contact.email %} * Contact: {{ spec.info.contact.email }}
 {% endif %} * Generated by: Rust OpenAPI Generator
 */

// Consolidated client
pub mod client;

{% set param_enums = collect_parameter_enums(operations) %}
{% if param_enums %}
// Parameter enums for type-safe API parameters
pub mod parameter_enums;
{% endif %}

// Individual endpoint modules
{% for operation in operations %}
pub mod {{ operation.rust_function_name }};
{% endfor %}

/// Unified error type that can represent any API error from any endpoint
#[derive(Debug, thiserror::Error)]
pub enum AlgodApiError {
{% for operation in operations %}
    #[error("{{ operation.rust_function_name | title }} error: {0:?}")]
    {{ operation.rust_function_name | pascal_case }}({{ operation.rust_function_name }}::{{ operation.rust_error_enum }}),
{% endfor %}
    #[error("Unknown API error: {0}")]
    Unknown(String),
}

{% for operation in operations %}
impl From<{{ operation.rust_function_name }}::{{ operation.rust_error_enum }}> for AlgodApiError {
    fn from(err: {{ operation.rust_function_name }}::{{ operation.rust_error_enum }}) -> Self {
        AlgodApiError::{{ operation.rust_function_name | pascal_case }}(err)
    }
}

{% endfor %}

/// The main error type for all algod client operations
#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("HTTP error: {0}")]
    Http(#[from] algokit_http_client::HttpError),
    #[error("Serialization error: {0}")]
    Serde(String),
    #[error("API error: {0}")]
    Api(#[from] AlgodApiError),
}

#[derive(Debug, PartialEq, Eq)]
pub enum ContentType {
    Json,
    MsgPack,
    Text,
    Unsupported(String),
}

impl From<&str> for ContentType {
    fn from(content_type: &str) -> Self {
        if content_type.contains("application/json") {
            ContentType::Json
        } else if content_type.contains("application/msgpack") {
            ContentType::MsgPack
        } else if content_type.contains("text/plain") {
            ContentType::Text
        } else {
            ContentType::Unsupported(content_type.to_string())
        }
    }
}

pub fn urlencode<T: AsRef<str>>(s: T) -> String {
    ::url::form_urlencoded::byte_serialize(s.as_ref().as_bytes()).collect()
}

// Re-export the consolidated client
pub use client::AlgodClient;

{% if param_enums %}
// Re-export parameter enums
pub use parameter_enums::*;
{% endif %}

// Re-export all endpoint functions
{% for operation in operations %}
pub use {{ operation.rust_function_name }}::{
    {{ operation.rust_function_name }},
    {{ operation.rust_error_enum }},
};
{% endfor %}
