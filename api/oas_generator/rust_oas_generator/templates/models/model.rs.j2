/*
 * {{ spec.info.title }}
 *
 * {{ spec.info.description or "API client generated from OpenAPI specification" }}
 *
 * The version of the OpenAPI document: {{ spec.info.version }}
 {% if spec.info.contact and spec.info.contact.email %} * Contact: {{ spec.info.contact.email }}
 {% endif %} * Generated by: Rust OpenAPI Generator
 */

{# Import macro for enum generation #}
{% from 'macros/enum_macros.j2' import generate_string_enum %}

use crate::models;
use serde::{Deserialize, Serialize};
{% if schema.is_string_enum %}
use std::fmt;
use std::str::FromStr;
{% endif %}
{% if schema.has_msgpack_fields %}
use serde_with::{Bytes, serde_as};
{% endif %}
{% if schema.has_signed_transaction_fields or schema.implements_algokit_msgpack %}
use algokit_transact::{SignedTransaction as AlgokitSignedTransaction, AlgorandMsgpack};
{% endif %}

{# Generate imports for custom types used in this schema #}
{% set custom_types = [] %}
{# For struct/object schemas inspect properties #}
{% for property in schema.properties %}
    {% set rust_type = property.rust_type_with_msgpack %}
    {# Extract base type from Vec<Type> or Option<Type> #}
    {% if rust_type.startswith('Vec<') %}
        {% set inner_type = rust_type[4:-1] %}
    {% elif rust_type.startswith('Option<') %}
        {% set inner_type = rust_type[7:-1] %}
    {% else %}
        {% set inner_type = rust_type %}
    {% endif %}

    {# Check if it's a custom type (starts with uppercase and doesn't contain :: or primitives) and it's not the current schema's own type #}
    {# Also exclude Vec<u8> and Vec<Vec<u8>> which are standard Rust types #}
    {% if inner_type and inner_type[0].isupper() and '::' not in inner_type and inner_type not in ['String', 'Vec', 'Option'] and not inner_type.startswith('i') and not inner_type.startswith('u') and inner_type != 'bool' and inner_type != schema.rust_struct_name and inner_type != 'Vec<u8>' %}
        {% if inner_type not in custom_types %}
            {% set _ = custom_types.append(inner_type) %}
        {% endif %}
    {% endif %}
{% endfor %}

{# Generate the import statements #}
{% for custom_type in custom_types %}
use crate::models::{{ custom_type }};
{% endfor %}
{# If this is an alias to a Vec<Something>, ensure Something is imported #}
{% if schema.schema_type == 'array' and schema.underlying_rust_type %}
    {% if schema.underlying_rust_type.startswith('Vec<') %}
        {% set alias_inner = schema.underlying_rust_type[4:-1] %}
        {% if alias_inner and alias_inner[0].isupper() and '::' not in alias_inner %}
use crate::models::{{ alias_inner }};
        {% endif %}
    {% endif %}
{% endif %}

{# Handle top-level array schemas as type aliases instead of empty structs #}
{% if schema.schema_type == 'array' and schema.underlying_rust_type %}
{% if schema.description %}
{{ schema.description | rust_doc_comment }}
{% endif %}
pub type {{ schema.rust_struct_name }} = {{ schema.underlying_rust_type }};
{# Handle string enum schemas as Rust enums #}
{% elif schema.is_string_enum %}
{{ generate_string_enum(schema.rust_struct_name, schema.enum_values, schema.description) }}
{% else %}
{% if schema.description %}
{{ schema.description | rust_doc_comment }}
{% endif %}
{% if schema.has_msgpack_fields %}
#[serde_as]
{% endif %}
{% set has_signed_tx = schema.has_signed_transaction_fields %}
{% set complex_signed_tx_fields = [] %}
{% for property in schema.properties %}
    {% if property.required and property.is_signed_transaction and not property.rust_type.startswith('Vec<') %}
        {% set _ = complex_signed_tx_fields.append(property) %}
    {% endif %}
{% endfor %}
{% set needs_manual_default = complex_signed_tx_fields|length > 0 %}
#[derive(Clone, {% if not needs_manual_default %}Default, {% endif %}Debug, PartialEq, Serialize, Deserialize)]
{% if schema.vendor_extensions.get('x-algokit-signed-txn') %}
// This struct represents a SignedTransaction and can be converted to/from AlgoKit's SignedTransaction
{% endif %}
pub struct {{ schema.rust_struct_name }} {
{% for property in schema.properties %}
    {% if property.description %}
    {{ property.description | rust_doc_comment(4) }}
    {% endif %}
    {% set is_account_related = schema.name in ['Account', 'AccountParticipation', 'AssetHolding', 'ApplicationLocalState', 'Application', 'Asset', 'AssetParams', 'ApplicationParams'] %}
    {% if schema.implements_algokit_msgpack and not is_account_related %}
    {% if property.is_base64_encoded %}
    {% if property.required %}
    #[serde_as(as = "Bytes")]
    {% else %}
    #[serde_as(as = "Option<Bytes>")]
    {% endif %}
    {% elif property.items and property.items.is_base64_encoded %}
    {% if property.required %}
    #[serde_as(as = "Vec<Bytes>")]
    {% else %}
    #[serde_as(as = "Option<Vec<Bytes>>")]
    {% endif %}
    {% endif %}
    {% else %}
    {% if property.is_base64_encoded %}
    {% if property.required %}
    #[serde_as(as = "serde_with::base64::Base64")]
    {% else %}
    #[serde_as(as = "Option<serde_with::base64::Base64>")]
    {% endif %}
    {% elif property.items and property.items.is_base64_encoded %}
    {% if property.required %}
    #[serde_as(as = "Vec<serde_with::base64::Base64>")]
    {% else %}
    #[serde_as(as = "Option<Vec<serde_with::base64::Base64>>")]
    {% endif %}
    {% endif %}
    {% endif %}
    #[serde(rename = "{{ property.name }}"{% if not property.required %}, skip_serializing_if = "Option::is_none"{% endif %})]
    {% if property.is_signed_transaction %}
    pub {{ property.rust_field_name }}: {% if property.required %}{% if property.rust_type.startswith('Vec<') %}Vec<AlgokitSignedTransaction>{% else %}AlgokitSignedTransaction{% endif %}{% else %}Option<{% if property.rust_type.startswith('Vec<') %}Vec<AlgokitSignedTransaction>{% else %}AlgokitSignedTransaction{% endif %}>{% endif %},
    {% else %}
    pub {{ property.rust_field_name }}: {% if property.required %}{{ property.rust_type_with_msgpack }}{% else %}Option<{{ property.rust_type_with_msgpack }}>{% endif %},
    {% endif %}
{% endfor %}
}
{% endif %}

{% if needs_manual_default %}
impl Default for {{ schema.rust_struct_name }} {
    fn default() -> Self {
        Self {
{% for property in schema.properties %}
            {% if property.is_signed_transaction %}
            {{ property.rust_field_name }}: {% if property.required %}{% if property.rust_type.startswith('Vec<') %}Vec::new(){% else %}AlgokitSignedTransaction {
                transaction: algokit_transact::Transaction::Payment(algokit_transact::PaymentTransactionFields {
                    header: algokit_transact::TransactionHeader {
                        sender: Default::default(),
                        fee: None,
                        first_valid: 0,
                        last_valid: 0,
                        genesis_hash: None,
                        genesis_id: None,
                        note: None,
                        rekey_to: None,
                        lease: None,
                        group: None,
                    },
                    receiver: Default::default(),
                    amount: 0,
                    close_remainder_to: None,
                }),
                signature: None,
                auth_address: None,
                multisignature: None,
            }{% endif %}{% else %}None{% endif %},
            {% elif property.required %}
            {{ property.rust_field_name }}: {% if property.rust_type == "String" %}"".to_string(){% elif property.rust_type.startswith('Vec<') %}Vec::new(){% elif property.rust_type.startswith('i') or property.rust_type.startswith('u') %}0{% elif property.rust_type == "bool" %}false{% elif property.rust_type == "serde_json::Value" %}serde_json::Value::Null{% else %}Default::default(){% endif %},
            {% else %}
            {{ property.rust_field_name }}: None,
            {% endif %}
{% endfor %}
        }
    }
}
{% endif %}

{% if schema.vendor_extensions.get('x-algokit-signed-txn') %}
impl From<AlgokitSignedTransaction> for {{ schema.rust_struct_name }} {
    fn from(signed_tx: AlgokitSignedTransaction) -> Self {
        // Convert AlgoKit SignedTransaction to this struct
        // This conversion should map the fields appropriately
        Self {
            // Map fields based on the actual schema structure
            // You may need to customize this based on the specific fields in your schema
            ..Default::default()
        }
    }
}

impl TryFrom<{{ schema.rust_struct_name }}> for AlgokitSignedTransaction {
    type Error = Box<dyn std::error::Error>;

    fn try_from(value: {{ schema.rust_struct_name }}) -> Result<Self, Self::Error> {
        // Convert this struct to AlgoKit SignedTransaction
        // This conversion should map the fields appropriately
        // You may need to customize this based on the specific fields in your schema
        todo!("Implement conversion to AlgoKit SignedTransaction based on your schema fields")
    }
}
{% endif %}

{% if schema.implements_algokit_msgpack and not (schema.schema_type == 'array' and schema.underlying_rust_type) and not schema.is_string_enum %}
impl AlgorandMsgpack for {{ schema.rust_struct_name }} {
    {% if schema.vendor_extensions.get('x-algokit-signed-txn') %}
    const PREFIX: &'static [u8] = b"";  // No prefix for SignedTransaction
    {% else %}
    const PREFIX: &'static [u8] = b"";  // Adjust prefix as needed for your specific type
    {% endif %}
}
{% endif %}

{% if not (schema.schema_type == 'array' and schema.underlying_rust_type) and not schema.is_string_enum %}
impl {{ schema.rust_struct_name }} {
    {% if schema.has_required_fields %}
    /// Constructor for {{ schema.rust_struct_name }}
    pub fn new({% for property in schema.properties if property.required %}{{ property.rust_field_name }}: {% if property.is_signed_transaction %}{% if property.rust_type.startswith('Vec<') %}Vec<AlgokitSignedTransaction>{% else %}AlgokitSignedTransaction{% endif %}{% else %}{{ property.rust_type_with_msgpack }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}) -> {{ schema.rust_struct_name }} {
        {{ schema.rust_struct_name }} {
{% for property in schema.properties if property.required %}
            {{ property.rust_field_name }},
{% endfor %}
{% for property in schema.properties if not property.required %}
            {{ property.rust_field_name }}: None,
{% endfor %}
        }
    }
    {% else %}
    /// Default constructor for {{ schema.rust_struct_name }}
    pub fn new() -> {{ schema.rust_struct_name }} {
        {{ schema.rust_struct_name }}::default()
    }
    {% endif %}

    {% if schema.implements_algokit_msgpack %}
    /// Encode this struct to msgpack bytes using AlgorandMsgpack trait
    pub fn to_msgpack(&self) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        Ok(self.encode()?)
    }

    /// Decode msgpack bytes to this struct using AlgorandMsgpack trait
    pub fn from_msgpack(bytes: &[u8]) -> Result<Self, Box<dyn std::error::Error>> {
        Ok(Self::decode(bytes)?)
    }
    {% endif %}
}
{% endif %}
